using NocodeX.Core.Exceptions;
using NocodeX.Core.Interfaces;
using NocodeX.Core.Models;
using NocodeX.Core.Models.Prompts;
using NocodeX.Infrastructure.CodeGeneration;
using Microsoft.Extensions.Logging;

namespace NocodeX.Infrastructure.SelfCorrection;

/// <summary>
/// Retries code generation with error context when verification fails.
/// </summary>
public sealed class SelfCorrectionEngine
{
    private readonly LlmCodeGenerator _codeGenerator;
    private readonly IVerificationService _verificationService;
    private readonly FileOutputMapper _fileMapper;
    private readonly ILogger<SelfCorrectionEngine> _logger;
    private readonly int _maxAttempts;

    /// <summary>
    /// Initializes a new instance of the <see cref="SelfCorrectionEngine"/> class.
    /// </summary>
    public SelfCorrectionEngine(
        LlmCodeGenerator codeGenerator,
        IVerificationService verificationService,
        FileOutputMapper fileMapper,
        ILogger<SelfCorrectionEngine> logger,
        int maxAttempts = 3)
    {
        _codeGenerator = codeGenerator;
        _verificationService = verificationService;
        _fileMapper = fileMapper;
        _logger = logger;
        _maxAttempts = maxAttempts;
    }

    /// <summary>
    /// Generates code, verifies it, and self-corrects on failure up to max attempts.
    /// </summary>
    /// <param name="context">Initial prompt context.</param>
    /// <param name="stack">Active stack configuration.</param>
    /// <param name="ct">Cancellation token.</param>
    /// <returns>Final task result after generation and verification.</returns>
    public async Task<TaskResult> GenerateAndVerifyAsync(
        PromptContext context,
        StackConfig stack,
        CancellationToken ct)
    {
        string? lastError = null;
        string? lastCode = null;

        for (int attempt = 1; attempt <= _maxAttempts; attempt++)
        {
            _logger.LogInformation("Generation attempt {Attempt}/{Max}",
                attempt, _maxAttempts);

            PromptContext currentContext = attempt == 1
                ? context
                : context with
                {
                    Type = PromptType.FixCompilationError,
                    ErrorContext = lastError,
                    PreviousAttempt = lastCode
                };

            GenerationResult genResult = await _codeGenerator.GenerateAsync(
                currentContext, stack, ct);

            if (genResult.Files.Count == 0)
            {
                lastError = "No code blocks generated by LLM";
                _logger.LogWarning("Attempt {Attempt}: No code generated", attempt);
                continue;
            }

            // Write files to disk
            IReadOnlyList<string> writtenFiles = await _fileMapper.WriteFilesAsync(
                genResult.Files, ct);

            lastCode = string.Join("\n\n", genResult.Files.Select(
                f => $"// {f.Key}\n{f.Value}"));

            // Verify
            IReadOnlyList<VerificationResult> verifyResults =
                await _verificationService.VerifyAsync(stack, ct);

            bool allPassed = verifyResults.All(v => v.Passed);

            if (allPassed)
            {
                _logger.LogInformation(
                    "Generation succeeded on attempt {Attempt}. Files: {Files}",
                    attempt, string.Join(", ", writtenFiles));

                return TaskResult.Success(
                    $"Generated {writtenFiles.Count} file(s) on attempt {attempt}",
                    writtenFiles);
            }

            VerificationResult? failedStep = verifyResults.FirstOrDefault(v => !v.Passed);
            lastError = $"Step '{failedStep?.StepName}' failed (exit {failedStep?.ExitCode}):\n" +
                        $"stdout: {failedStep?.StandardOutput}\n" +
                        $"stderr: {failedStep?.StandardError}";

            _logger.LogWarning("Attempt {Attempt} verification failed: {Step}",
                attempt, failedStep?.StepName);
        }

        throw new SelfCorrectionExhaustedException(_maxAttempts, lastError ?? "Unknown error");
    }
}
